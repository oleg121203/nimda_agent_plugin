name: Bulletproof Codex Priority Merge

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, work]
  push:
    branches: 
      - 'codex/**'
      - 'bgrzdn-codex/**'

jobs:
  bulletproof-codex-merge:
    if: contains(github.head_ref, 'codex') || contains(github.head_ref, 'bgrzdn-codex') || contains(github.ref, 'codex')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
    
    steps:
    - name: Checkout repository with full history
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ github.head_ref || github.ref }}

    - name: Configure Git with bulletproof settings
      run: |
        git config --global user.name "Bulletproof Codex Bot"
        git config --global user.email "codex-bulletproof@noreply.github.com"
        git config --global merge.tool "resolve-codex-priority"
        git config --global merge.resolve-codex-priority.cmd 'echo "Auto-resolving with Codex priority"; git checkout --theirs "$MERGED"; exit 0'
        git config --global core.autocrlf false
        git config --global core.safecrlf false

    - name: Analyze repository state and branches
      run: |
        echo "ğŸ” Analyzing repository state..."
        echo "Current branch: $(git branch --show-current)"
        echo "Target branch: ${{ github.base_ref || 'main' }}"
        echo "Source branch: ${{ github.head_ref || github.ref_name }}"
        
        # Fetch all branches
        git fetch origin --all
        
        # Check for unmerged changes in all relevant branches
        echo "ğŸ“‹ Checking for unmerged changes..."
        
        for branch in $(git branch -r | grep -E "(origin/main|origin/work|origin/codex)" | sed 's/origin\///g' | tr -d ' '); do
          if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
            unmerged=$(git rev-list --count main..origin/$branch 2>/dev/null || echo "0")
            echo "Branch $branch: $unmerged unmerged commits"
            if [ "$unmerged" -gt 0 ]; then
              echo "BRANCH_TO_MERGE_$branch=$unmerged" >> $GITHUB_ENV
            fi
          fi
        done

    - name: Create backup and safety branches
      run: |
        echo "ğŸ’¾ Creating safety backups..."
        
        # Create backup of main
        backup_main="backup-main-$(date +%Y%m%d-%H%M%S)"
        git branch "$backup_main" origin/main
        echo "BACKUP_MAIN=$backup_main" >> $GITHUB_ENV
        
        # Create backup of current state
        backup_current="backup-current-$(date +%Y%m%d-%H%M%S)"
        git branch "$backup_current" HEAD
        echo "BACKUP_CURRENT=$backup_current" >> $GITHUB_ENV
        
        echo "âœ… Backups created: $backup_main, $backup_current"

    - name: Determine merge strategy and priority
      run: |
        echo "ğŸ§  Determining optimal merge strategy..."
        
        current_branch="${{ github.head_ref || github.ref_name }}"
        target_branch="${{ github.base_ref || 'main' }}"
        
        # Get commit information
        source_commit=$(git rev-parse HEAD)
        target_commit=$(git rev-parse "origin/$target_branch")
        
        source_time=$(git log -1 --format="%ct" "$source_commit")
        target_time=$(git log -1 --format="%ct" "$target_commit")
        
        # Check commit authors/messages for automation detection
        source_author=$(git log -1 --format="%an" "$source_commit")
        source_msg=$(git log -1 --format="%s" "$source_commit")
        
        echo "ğŸ“Š Source commit: $source_commit at $(date -d @$source_time)"
        echo "ğŸ“Š Target commit: $target_commit at $(date -d @$target_time)"
        echo "ğŸ“Š Source author: $source_author"
        
        # Determine if source is automated or manual
        if [[ "$source_msg" =~ (Auto-merge|Merge branch|GitHub Actions) ]] || 
           [[ "$source_author" =~ (Bot|GitHub|Actions|Codex) ]]; then
          echo "COMMIT_TYPE=automatic" >> $GITHUB_ENV
          echo "ğŸ¤– Detected automatic commit"
        else
          echo "COMMIT_TYPE=manual" >> $GITHUB_ENV
          echo "ğŸ‘¤ Detected manual commit"
        fi
        
        # For Codex branches, always prioritize Codex in automatic mode
        if [[ "$current_branch" =~ codex ]]; then
          echo "MERGE_STRATEGY=codex_priority" >> $GITHUB_ENV
          echo "ğŸ¯ Using Codex priority strategy"
        else
          echo "MERGE_STRATEGY=standard" >> $GITHUB_ENV
          echo "ğŸ“‹ Using standard merge strategy"
        fi

    - name: Execute bulletproof merge with multi-branch support
      run: |
        echo "ğŸ›¡ï¸ Executing bulletproof merge..."
        
        target_branch="${{ github.base_ref || 'main' }}"
        merge_strategy="${MERGE_STRATEGY:-codex_priority}"
        
        # Switch to target branch
        git checkout "origin/$target_branch"
        git checkout -b "merge-temp-$(date +%s)"
        
        # Collect all branches that need merging
        branches_to_merge=()
        
        # Add the main source branch
        branches_to_merge+=("${{ github.head_ref || github.ref_name }}")
        
        # Add other priority branches with unmerged changes
        priority_order=("codex" "work" "main")
        
        for priority in "${priority_order[@]}"; do
          for branch in $(git branch -r | grep "origin.*$priority" | sed 's/origin\///g' | tr -d ' '); do
            if [ "$branch" != "${{ github.head_ref || github.ref_name }}" ] && 
               git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              unmerged=$(git rev-list --count HEAD..origin/$branch 2>/dev/null || echo "0")
              if [ "$unmerged" -gt 0 ]; then
                branches_to_merge+=("$branch")
                echo "â• Added $branch to merge queue ($unmerged commits)"
              fi
            fi
          done
        done
        
        echo "ğŸ”„ Merging branches in priority order: ${branches_to_merge[*]}"
        
        # Execute the merge
        merge_success=true
        
        for branch in "${branches_to_merge[@]}"; do
          echo "ğŸ”„ Merging branch: $branch"
          
          if [ "$merge_strategy" = "codex_priority" ]; then
            # Codex priority: prefer incoming changes
            if ! git merge "origin/$branch" --no-edit -X theirs; then
              echo "âš ï¸ Conflicts detected in $branch, resolving with Codex priority..."
              
              # Resolve all conflicts in favor of incoming branch
              git status --porcelain | grep "^UU" | while read -r line; do
                file=$(echo "$line" | cut -c4-)
                echo "âš¡ Resolving $file with Codex priority"
                git checkout --theirs "$file"
                git add "$file"
              done
              
              # Handle add/delete conflicts
              git status --porcelain | grep -E "^(DU|UD|AU|UA)" | while read -r line; do
                file=$(echo "$line" | cut -c4-)
                echo "âš¡ Resolving add/delete conflict: $file"
                git checkout --theirs "$file" 2>/dev/null || git rm "$file" 2>/dev/null || true
                git add "$file" 2>/dev/null || true
              done
              
              # Commit the resolution
              if ! git commit --no-edit -m "Auto-resolve: Codex priority merge of $branch"; then
                echo "âŒ Failed to commit resolution for $branch"
                merge_success=false
                break
              fi
            fi
          else
            # Standard merge
            if ! git merge "origin/$branch" --no-edit; then
              echo "âŒ Standard merge failed for $branch"
              merge_success=false
              break
            fi
          fi
          
          echo "âœ… Successfully merged $branch"
        done
        
        if [ "$merge_success" = true ]; then
          echo "MERGE_SUCCESS=true" >> $GITHUB_ENV
          echo "FINAL_COMMIT=$(git rev-parse HEAD)" >> $GITHUB_ENV
          echo "âœ… All merges completed successfully"
        else
          echo "MERGE_SUCCESS=false" >> $GITHUB_ENV
          echo "âŒ Merge process failed"
        fi

    - name: Push merged changes and update branches
      if: env.MERGE_SUCCESS == 'true'
      run: |
        echo "ğŸš€ Pushing merged changes..."
        
        target_branch="${{ github.base_ref || 'main' }}"
        
        # Push to target branch
        git push origin HEAD:"$target_branch"
        
        # Update work branch if it exists and is different from target
        if [ "$target_branch" != "work" ] && git rev-parse --verify origin/work >/dev/null 2>&1; then
          echo "ğŸ”„ Updating work branch..."
          git push origin HEAD:work
        fi
        
        echo "âœ… All branches updated successfully"

    - name: Clean up backup branches
      if: env.MERGE_SUCCESS == 'true'
      run: |
        echo "ğŸ§¹ Cleaning up backup branches..."
        
        # Remove backup branches (keep them for a short time in case of issues)
        # git branch -D "$BACKUP_MAIN" "$BACKUP_CURRENT" || true
        
        echo "â„¹ï¸ Backup branches preserved for safety: $BACKUP_MAIN, $BACKUP_CURRENT"

    - name: Handle merge failure
      if: env.MERGE_SUCCESS == 'false'
      run: |
        echo "âŒ Merge failed - initiating recovery procedures..."
        
        # Reset to backup state
        git reset --hard "$BACKUP_CURRENT"
        
        # Create issue for manual intervention
        echo "RECOVERY_NEEDED=true" >> $GITHUB_ENV
        echo "FAILURE_REASON=Bulletproof merge failed with conflicts" >> $GITHUB_ENV

    - name: Comment on PR with detailed results
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const mergeSuccess = process.env.MERGE_SUCCESS === 'true';
          const commitType = process.env.COMMIT_TYPE || 'unknown';
          const mergeStrategy = process.env.MERGE_STRATEGY || 'standard';
          const finalCommit = process.env.FINAL_COMMIT || 'unknown';
          
          let message;
          
          if (mergeSuccess) {
            message = `ğŸ¤– **Bulletproof Codex Merge Completed**
            
            âœ… Successfully merged with bulletproof strategy
            ğŸ¯ **Merge Strategy**: ${mergeStrategy}
            ğŸ” **Commit Type**: ${commitType}
            ğŸ“‹ **Target Branch**: \`${{ github.base_ref }}\`
            ğŸ”— **Final Commit**: \`${finalCommit.substring(0, 8)}\`
            
            **Multi-Branch Merge Results:**
            - âœ… All priority branches merged successfully
            - âœ… Conflicts resolved with Codex priority
            - âœ… Repository state synchronized across all branches
            
            **Safety Measures Applied:**
            - ğŸ’¾ Backup branches created and preserved
            - ï¿½ï¸ Bulletproof conflict resolution
            - ğŸ”„ Multi-branch synchronization
            
            The merge strategy ensures Codex-generated changes take precedence while maintaining system stability.`;
          } else {
            message = `âŒ **Bulletproof Merge Failed**
            
            âš ï¸ The automated merge encountered unresolvable conflicts
            ğŸ”„ **Strategy Used**: ${mergeStrategy}
            ğŸ” **Commit Type**: ${commitType}
            
            **Recovery Actions Taken:**
            - ğŸ’¾ Repository state restored from backup
            - ğŸ“ Manual intervention required
            - ğŸ›¡ï¸ No data loss occurred
            
            **Next Steps:**
            1. Review conflicts manually
            2. Use \`bulletproof_sync.sh recover\` locally
            3. Resolve conflicts with appropriate priority
            
            Manual merge required - automated systems could not resolve all conflicts safely.`;
          }
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: message
          });

    - name: Close PR if merge successful
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request' && env.MERGE_SUCCESS == 'true'
      with:
        script: |
          await github.rest.pulls.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
            state: 'closed'
          });

  label-and-track:
    if: contains(github.head_ref, 'codex') || contains(github.head_ref, 'bgrzdn-codex')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    
    steps:
    - name: Label PR with detailed tracking
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const labels = ['codex-priority', 'bulletproof-merge', 'auto-sync'];
          
          // Add branch-specific labels
          const headRef = '${{ github.head_ref }}';
          if (headRef.includes('codex')) {
            labels.push('codex-branch');
          }
          if (headRef.includes('work')) {
            labels.push('work-integration');
          }
          
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            labels: labels
          });
