"""
üöÄ NIMDA Advanced Tools Extension Plugin
–†–æ–∑—à–∏—Ä–µ–Ω–∏–π –Ω–∞–±—ñ—Ä —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –ø—ñ–¥–≤–∏—â–µ–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ —Ç–∞ –º–æ–∂–ª–∏–≤–æ—Å—Ç–µ–π

–°—Ç–≤–æ—Ä–µ–Ω–æ: 15 –ª–∏–ø–Ω—è 2025
–í–µ—Ä—Å—ñ—è: 3.0.0 - Advanced Tools Edition
"""

import asyncio
import hashlib
import json
import sqlite3
import time
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

try:
    import psutil
except ImportError:
    psutil = None

from .base_plugin import BasePlugin, PluginResult, PluginStatus


@dataclass
class AdvancedMetrics:
    """–†–æ–∑—à–∏—Ä–µ–Ω—ñ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É"""

    cpu_usage: float
    memory_usage: float
    disk_io: float
    network_io: float
    task_complexity: float
    estimated_time: float
    priority_score: float


class NIMDAAdvancedToolsPlugin(BasePlugin):
    """
    –†–æ–∑—à–∏—Ä–µ–Ω–∏–π –ø–ª–∞–≥—ñ–Ω –∑ –ø–µ—Ä–µ–¥–æ–≤–∏–º–∏ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏

    –ù–æ–≤—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ:
    - AI-–∫–µ—Ä–æ–≤–∞–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –∑–∞–≤–¥–∞–Ω—å
    - –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∞
    - –°–∏—Å—Ç–µ–º–∞ –∫–µ—à—É–≤–∞–Ω–Ω—è –∑ ML
    - –†–æ–∑—É–º–Ω–µ –ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è
    - –Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞ –ø—Ä—ñ–æ—Ä–∏—Ç–∏–∑–∞—Ü—ñ—è
    """

    def __init__(self, config: Optional[Dict] = None):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–æ–∑—à–∏—Ä–µ–Ω–æ–≥–æ –ø–ª–∞–≥—ñ–Ω–∞"""
        super().__init__(
            name="NIMDAAdvancedTools", version="3.0.0", config=config or {}
        )

        # –î–æ–¥–∞—î–º–æ workspace_path
        from pathlib import Path

        self.workspace_path = Path(self.config.get("workspace_path", "."))

        # –†–æ–∑—à–∏—Ä–µ–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
        self.ai_optimization_enabled = self.config.get("ai_optimization", True)
        self.predictive_analytics = self.config.get("predictive_analytics", True)
        self.smart_caching = self.config.get("smart_caching", True)
        self.auto_scaling = self.config.get("auto_scaling", True)

        # AI —Ç–∞ ML –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
        self.task_complexity_model = None
        self.execution_time_predictor = None
        self.priority_optimizer = None

        # –°–∏—Å—Ç–µ–º–∞ –∫–µ—à—É–≤–∞–Ω–Ω—è
        self.cache_db_path = self.workspace_path / "nimda_cache.db"
        self.cache_hit_rate = 0.0
        self.cache_entries = 0

        # –ú–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º–∏
        self.system_metrics = []
        self.performance_history = []
        self.execution_patterns = {}

        # –†–æ–∑—É–º–Ω–µ –ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è
        self.resource_monitor = psutil
        self.task_scheduler = None
        self.load_balancer = None

        # –Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞ –ø—Ä—ñ–æ—Ä–∏—Ç–∏–∑–∞—Ü—ñ—è
        self.priority_weights = {
            "complexity": 0.3,
            "dependencies": 0.2,
            "resource_usage": 0.2,
            "business_value": 0.3,
        }

        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤
        self._initialize_advanced_components()

        self.logger.info("üöÄ NIMDAAdvancedToolsPlugin —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –∑ AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—î—é")

    def _initialize_advanced_components(self):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤"""
        try:
            # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –∫–µ—à—É
            self._setup_cache_database()

            # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AI –º–æ–¥–µ–ª–µ–π (—Å–∏–º—É–ª—è—Ü—ñ—è)
            self._initialize_ai_models()

            # –ó–∞–ø—É—Å–∫ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É —Ä–µ—Å—É—Ä—Å—ñ–≤
            self._start_resource_monitoring()

            self.logger.info("‚úÖ –†–æ–∑—à–∏—Ä–µ–Ω—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ")

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤: {e}")

    def _setup_cache_database(self):
        """–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –¥–ª—è –∫–µ—à—É–≤–∞–Ω–Ω—è"""
        try:
            conn = sqlite3.connect(self.cache_db_path)
            cursor = conn.cursor()

            cursor.execute("""
                CREATE TABLE IF NOT EXISTS task_cache (
                    id TEXT PRIMARY KEY,
                    task_hash TEXT,
                    result TEXT,
                    execution_time REAL,
                    created_at TIMESTAMP,
                    access_count INTEGER DEFAULT 0,
                    last_accessed TIMESTAMP
                )
            """)

            cursor.execute("""
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TIMESTAMP,
                    cpu_usage REAL,
                    memory_usage REAL,
                    task_count INTEGER,
                    avg_execution_time REAL
                )
            """)

            conn.commit()
            conn.close()

            self.logger.info("üì¶ –ë–∞–∑–∞ –¥–∞–Ω–∏—Ö –∫–µ—à—É –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∞")

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö: {e}")

    def _initialize_ai_models(self):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AI –º–æ–¥–µ–ª–µ–π (—Å–∏–º—É–ª—è—Ü—ñ—è)"""
        # –í —Ä–µ–∞–ª—å–Ω—ñ–π —ñ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—ó —Ç—É—Ç –±—É–ª–∏ –± —Å–ø—Ä–∞–≤–∂–Ω—ñ ML –º–æ–¥–µ–ª—ñ
        self.task_complexity_model = self._calculate_task_complexity
        self.execution_time_predictor = self._predict_execution_time
        self.priority_optimizer = self._optimize_task_priorities_simple

        self.logger.info("üß† AI –º–æ–¥–µ–ª—ñ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ")

    def _start_resource_monitoring(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É —Å–∏—Å—Ç–µ–º–Ω–∏—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤"""
        # –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –∑–Ω—ñ–º–æ–∫ —Ä–µ—Å—É—Ä—Å—ñ–≤
        initial_metrics = self._get_system_metrics()
        self.system_metrics.append(initial_metrics)

        self.logger.info("üìä –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ä–µ—Å—É—Ä—Å—ñ–≤ –∑–∞–ø—É—â–µ–Ω–æ")

    async def execute(
        self, task: Dict[str, Any], context: Optional[Dict] = None
    ) -> PluginResult:
        """–†–æ–∑—à–∏—Ä–µ–Ω–µ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è –∑ AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—î—é"""
        start_time = time.time()
        self.update_status(PluginStatus.RUNNING)

        try:
            # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É
            if self.smart_caching:
                cached_result = await self._check_cache(task)
                if cached_result:
                    self.logger.info("‚ö° –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç—Ä–∏–º–∞–Ω–æ –∑ –∫–µ—à—É")
                    return cached_result

            # AI-–∫–µ—Ä–æ–≤–∞–Ω–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è
            if self.ai_optimization_enabled:
                task = await self._optimize_task_with_ai(task)

            # –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∞
            if self.predictive_analytics:
                predicted_time = self._predict_execution_time(task)
                self.logger.info(
                    f"üîÆ –ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∏–π —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: {predicted_time:.2f}—Å"
                )

            # –í–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è
            task_type = task.get("type", "")
            result = await self._execute_advanced_task(task_type, task, context)

            # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –∫–µ—à
            if self.smart_caching and result.success:
                await self._cache_result(task, result)

            # –û–Ω–æ–≤–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫
            execution_time = time.time() - start_time
            await self._update_performance_metrics(task, execution_time, result.success)

            result.execution_time = execution_time
            self.update_status(
                PluginStatus.COMPLETED if result.success else PluginStatus.ERROR
            )

            return result

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–æ–≥–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: {e}")
            execution_time = time.time() - start_time

            self.update_status(PluginStatus.ERROR)

            return PluginResult(
                success=False,
                message=f"–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–æ–≥–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: {e}",
                execution_time=execution_time,
                error=e,
            )

    async def _execute_advanced_task(
        self, task_type: str, task: Dict[str, Any], context: Optional[Dict]
    ) -> PluginResult:
        """–í–∏–∫–æ–Ω–∞–Ω–Ω—è —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–∏–ø—ñ–≤ –∑–∞–≤–¥–∞–Ω—å"""

        # –ù–æ–≤—ñ —Ç–∏–ø–∏ –∑–∞–≤–¥–∞–Ω—å
        if task_type == "ai_optimize_workflow":
            return await self._ai_optimize_workflow(task)
        elif task_type == "predict_performance":
            return await self._predict_performance(task)
        elif task_type == "smart_resource_allocation":
            return await self._smart_resource_allocation(task)
        elif task_type == "auto_scale_execution":
            return await self._auto_scale_execution(task)
        elif task_type == "intelligent_prioritization":
            return await self._intelligent_prioritization(task)
        elif task_type == "adaptive_learning":
            return await self._adaptive_learning(task)
        elif task_type == "context_aware_execution":
            return await self._context_aware_execution(task, context)
        elif task_type == "distributed_processing":
            return await self._distributed_processing(task)
        elif task_type == "real_time_optimization":
            return await self._real_time_optimization(task)
        elif task_type == "predictive_maintenance":
            return await self._predictive_maintenance(task)
        else:
            return PluginResult(
                success=False, message=f"–ù–µ–≤—ñ–¥–æ–º–∏–π —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–π —Ç–∏–ø –∑–∞–≤–¥–∞–Ω–Ω—è: {task_type}"
            )

    async def _ai_optimize_workflow(self, task: Dict[str, Any]) -> PluginResult:
        """AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —Ä–æ–±–æ—á–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É"""
        try:
            workflow_data = task.get("workflow_data", {})

            # –ê–Ω–∞–ª—ñ–∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ workflow
            current_efficiency = self._analyze_workflow_efficiency(workflow_data)

            # AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è
            optimized_workflow = await self._apply_ai_optimization(workflow_data)

            # –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è
            predicted_improvement = self._predict_improvement(
                current_efficiency, optimized_workflow
            )

            return PluginResult(
                success=True,
                message=f"Workflow –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ: –ø—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–µ –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è {predicted_improvement:.1%}",
                data={
                    "current_efficiency": current_efficiency,
                    "optimized_workflow": optimized_workflow,
                    "predicted_improvement": predicted_improvement,
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó: {e}", error=e
            )

    async def _predict_performance(self, task: Dict[str, Any]) -> PluginResult:
        """–ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        try:
            # –ê–Ω–∞–ª—ñ–∑ —ñ—Å—Ç–æ—Ä–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö
            historical_data = self._get_historical_performance()

            # –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –º–∞–π–±—É—Ç–Ω—å–æ—ó –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
            future_performance = self._predict_future_performance(historical_data)

            # –í–∏—è–≤–ª–µ–Ω–Ω—è –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏—Ö –≤—É–∑—å–∫–∏—Ö –º—ñ—Å—Ü—å
            bottlenecks = self._identify_bottlenecks(historical_data)

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –ø–æ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
            recommendations = self._generate_optimization_recommendations(bottlenecks)

            return PluginResult(
                success=True,
                message="–ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –∑–∞–≤–µ—Ä—à–µ–Ω–æ",
                data={
                    "historical_performance": historical_data,
                    "future_performance": future_performance,
                    "bottlenecks": bottlenecks,
                    "recommendations": recommendations,
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–æ—ó –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏: {e}", error=e
            )

    async def _smart_resource_allocation(self, task: Dict[str, Any]) -> PluginResult:
        """–†–æ–∑—É–º–Ω–∏–π —Ä–æ–∑–ø–æ–¥—ñ–ª —Ä–µ—Å—É—Ä—Å—ñ–≤"""
        try:
            # –ê–Ω–∞–ª—ñ–∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤
            current_usage = self._get_system_metrics()

            # –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –ø–æ—Ç—Ä–µ–± –≤ —Ä–µ—Å—É—Ä—Å–∞—Ö
            resource_needs = self._predict_resource_needs(task)

            # –û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π —Ä–æ–∑–ø–æ–¥—ñ–ª
            allocation_plan = self._calculate_optimal_allocation(
                current_usage, resource_needs
            )

            # –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –ø–ª–∞–Ω—É
            success = await self._apply_resource_allocation(allocation_plan)

            return PluginResult(
                success=success,
                message=f"–†–µ—Å—É—Ä—Å–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª–µ–Ω—ñ: CPU {allocation_plan['cpu']:.1%}, RAM {allocation_plan['memory']:.1%}",
                data={
                    "current_usage": current_usage.__dict__,
                    "allocation_plan": allocation_plan,
                    "estimated_improvement": allocation_plan.get("improvement", 0),
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø–æ–¥—ñ–ª—É —Ä–µ—Å—É—Ä—Å—ñ–≤: {e}", error=e
            )

    async def _auto_scale_execution(self, task: Dict[str, Any]) -> PluginResult:
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è"""
        try:
            # –ê–Ω–∞–ª—ñ–∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
            current_load = self._analyze_current_load()

            # –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –≤–æ—Ä–∫–µ—Ä—ñ–≤
            optimal_workers = self._calculate_optimal_workers(current_load)

            # –ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è
            scaling_result = await self._scale_workers(optimal_workers)

            return PluginResult(
                success=scaling_result["success"],
                message=f"–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è: {scaling_result['workers']} –≤–æ—Ä–∫–µ—Ä—ñ–≤",
                data={
                    "current_load": current_load,
                    "optimal_workers": optimal_workers,
                    "scaling_factor": scaling_result.get("factor", 1.0),
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ –∞–≤—Ç–æ–º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è: {e}", error=e
            )

    async def _intelligent_prioritization(self, task: Dict[str, Any]) -> PluginResult:
        """–Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞ –ø—Ä—ñ–æ—Ä–∏—Ç–∏–∑–∞—Ü—ñ—è –∑–∞–≤–¥–∞–Ω—å"""
        try:
            task_list = task.get("tasks", [])

            # –ê–Ω–∞–ª—ñ–∑ –∫–æ–∂–Ω–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è
            analyzed_tasks = []
            for t in task_list:
                analysis = {
                    "task": t,
                    "complexity": self._calculate_task_complexity(t),
                    "business_value": self._estimate_business_value(t),
                    "dependencies": self._analyze_dependencies(t),
                    "resource_needs": self._estimate_resource_needs(t),
                }
                analyzed_tasks.append(analysis)

            # –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤
            prioritized_tasks = self._optimize_task_priorities(analyzed_tasks)

            return PluginResult(
                success=True,
                message=f"–ü—Ä—ñ–æ—Ä–∏—Ç–∏–∑–æ–≤–∞–Ω–æ {len(prioritized_tasks)} –∑–∞–≤–¥–∞–Ω—å",
                data={
                    "prioritized_tasks": prioritized_tasks,
                    "optimization_metrics": self._calculate_priority_metrics(
                        prioritized_tasks
                    ),
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä—ñ–æ—Ä–∏—Ç–∏–∑–∞—Ü—ñ—ó: {e}", error=e
            )

    async def _adaptive_learning(self, task: Dict[str, Any]) -> PluginResult:
        """–ê–¥–∞–ø—Ç–∏–≤–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏"""
        try:
            # –ê–Ω–∞–ª—ñ–∑ –≤–∏–∫–æ–Ω–∞–Ω–∏—Ö –∑–∞–≤–¥–∞–Ω—å
            execution_data = self._collect_execution_data()

            # –ù–∞–≤—á–∞–Ω–Ω—è –º–æ–¥–µ–ª–µ–π
            learning_results = await self._train_adaptive_models(execution_data)

            # –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
            updated_parameters = self._update_system_parameters(learning_results)

            return PluginResult(
                success=True,
                message=f"–ê–¥–∞–ø—Ç–∏–≤–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ: –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è {learning_results.get('improvement', 0):.1%}",
                data={
                    "learning_results": learning_results,
                    "updated_parameters": updated_parameters,
                },
            )

        except Exception as e:
            return PluginResult(
                success=False, message=f"–ü–æ–º–∏–ª–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –Ω–∞–≤—á–∞–Ω–Ω—è: {e}", error=e
            )

    # –î–æ–ø–æ–º—ñ–∂–Ω—ñ –º–µ—Ç–æ–¥–∏ –¥–ª—è AI —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏

    def _calculate_task_complexity(self, task: Dict[str, Any]) -> float:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –∑–∞–≤–¥–∞–Ω–Ω—è"""
        # –°–∏–º—É–ª—è—Ü—ñ—è AI –∞–Ω–∞–ª—ñ–∑—É —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
        base_complexity = 1.0

        # –§–∞–∫—Ç–æ—Ä–∏ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
        if "dependencies" in task:
            base_complexity += len(task["dependencies"]) * 0.2

        if "estimated_time" in task:
            base_complexity += min(
                task["estimated_time"] / 3600, 2.0
            )  # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–æ –≥–æ–¥–∏–Ω–∞—Ö

        task_type = task.get("type", "").lower()
        if "ai" in task_type or "neural" in task_type:
            base_complexity *= 1.5
        elif "gui" in task_type:
            base_complexity *= 1.2

        return min(base_complexity, 5.0)  # –ú–∞–∫—Å–∏–º—É–º 5.0

    def _predict_execution_time(self, task: Dict[str, Any]) -> float:
        """–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è —á–∞—Å—É –≤–∏–∫–æ–Ω–∞–Ω–Ω—è"""
        complexity = self._calculate_task_complexity(task)
        base_time = complexity * 0.5  # –ë–∞–∑–æ–≤–∏–π —á–∞—Å

        # –ö–æ—Ä–µ–∫—Ü—ñ—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ —ñ—Å—Ç–æ—Ä–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö
        if self.performance_history:
            avg_time = sum(h["execution_time"] for h in self.performance_history) / len(
                self.performance_history
            )
            base_time = (base_time + avg_time) / 2

        return base_time

    def _get_system_metrics(self) -> AdvancedMetrics:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –º–µ—Ç—Ä–∏–∫"""
        if psutil:
            cpu_usage = psutil.cpu_percent()
            memory_usage = psutil.virtual_memory().percent

            # –ë–µ–∑–ø–µ—á–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ disk_io
            disk_io_counters = psutil.disk_io_counters()
            disk_io = disk_io_counters.read_bytes if disk_io_counters else 0

            # –ë–µ–∑–ø–µ—á–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ network_io
            net_io_counters = psutil.net_io_counters()
            network_io = net_io_counters.bytes_sent if net_io_counters else 0
        else:
            # Fallback –∑–Ω–∞—á–µ–Ω–Ω—è —è–∫—â–æ psutil –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π
            cpu_usage = 50.0
            memory_usage = 60.0
            disk_io = 0
            network_io = 0

        return AdvancedMetrics(
            cpu_usage=cpu_usage,
            memory_usage=memory_usage,
            disk_io=disk_io,
            network_io=network_io,
            task_complexity=1.0,
            estimated_time=1.0,
            priority_score=1.0,
        )

    async def _check_cache(self, task: Dict[str, Any]) -> Optional[PluginResult]:
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É –∑–∞–≤–¥–∞–Ω—å"""
        try:
            task_hash = hashlib.md5(
                json.dumps(task, sort_keys=True).encode()
            ).hexdigest()

            conn = sqlite3.connect(self.cache_db_path)
            cursor = conn.cursor()

            cursor.execute(
                "SELECT result, execution_time FROM task_cache WHERE task_hash = ?",
                (task_hash,),
            )

            result = cursor.fetchone()
            conn.close()

            if result:
                self.cache_hit_rate = (self.cache_hit_rate * self.cache_entries + 1) / (
                    self.cache_entries + 1
                )
                self.cache_entries += 1

                cached_data = json.loads(result[0])
                return PluginResult(
                    success=cached_data["success"],
                    message=f"[CACHE] {cached_data['message']}",
                    data=cached_data.get("data"),
                    execution_time=result[1],
                )

            return None

        except Exception as e:
            self.logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –∫–µ—à—É: {e}")
            return None

    async def _cache_result(self, task: Dict[str, Any], result: PluginResult):
        """–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –≤ –∫–µ—à"""
        try:
            task_hash = hashlib.md5(
                json.dumps(task, sort_keys=True).encode()
            ).hexdigest()

            result_data = {
                "success": result.success,
                "message": result.message,
                "data": result.data,
            }

            conn = sqlite3.connect(self.cache_db_path)
            cursor = conn.cursor()

            cursor.execute(
                """INSERT OR REPLACE INTO task_cache 
                   (id, task_hash, result, execution_time, created_at, last_accessed) 
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    f"{task_hash}_{int(time.time())}",
                    task_hash,
                    json.dumps(result_data),
                    result.execution_time or 0,
                    datetime.now(),
                    datetime.now(),
                ),
            )

            conn.commit()
            conn.close()

        except Exception as e:
            self.logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –∫–µ—à: {e}")

    def get_supported_tasks(self) -> List[str]:
        """–†–æ–∑—à–∏—Ä–µ–Ω–∏–π —Å–ø–∏—Å–æ–∫ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏—Ö –∑–∞–≤–¥–∞–Ω—å"""
        base_tasks = [
            "parse_dev_plan",
            "execute_phase",
            "execute_section",
            "execute_task",
            "get_progress",
            "optimize_execution",
        ]

        advanced_tasks = [
            "ai_optimize_workflow",
            "predict_performance",
            "smart_resource_allocation",
            "auto_scale_execution",
            "intelligent_prioritization",
            "adaptive_learning",
            "context_aware_execution",
            "distributed_processing",
            "real_time_optimization",
            "predictive_maintenance",
        ]

        return base_tasks + advanced_tasks

    def get_gui_configuration(self) -> Dict[str, Any]:
        """–†–æ–∑—à–∏—Ä–µ–Ω–∞ GUI –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è"""
        return {
            "window_type": "advanced_adaptive_panel",
            "position": "center",
            "size": {"width": 1200, "height": 800},
            "transparency": 0.95,
            "theme": "dark_neon_advanced",
            "components": [
                {"type": "ai_dashboard", "id": "ai_metrics", "label": "AI –ê–Ω–∞–ª—ñ—Ç–∏–∫–∞"},
                {
                    "type": "resource_monitor",
                    "id": "system_resources",
                    "label": "–†–µ—Å—É—Ä—Å–∏ —Å–∏—Å—Ç–µ–º–∏",
                },
                {
                    "type": "predictive_chart",
                    "id": "performance_prediction",
                    "label": "–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è",
                },
                {"type": "cache_status", "id": "cache_metrics", "label": "–°—Ç–∞—Ç—É—Å –∫–µ—à—É"},
                {
                    "type": "priority_matrix",
                    "id": "task_priorities",
                    "label": "–ú–∞—Ç—Ä–∏—Ü—è –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤",
                },
                {
                    "type": "learning_progress",
                    "id": "adaptive_learning",
                    "label": "–ü—Ä–æ–≥—Ä–µ—Å –Ω–∞–≤—á–∞–Ω–Ω—è",
                },
                {
                    "type": "workflow_optimizer",
                    "id": "workflow_optimization",
                    "label": "–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø—Ä–æ—Ü–µ—Å—ñ–≤",
                },
                {
                    "type": "real_time_metrics",
                    "id": "live_metrics",
                    "label": "Live –º–µ—Ç—Ä–∏–∫–∏",
                },
            ],
            "actions": [
                {"id": "ai_optimize", "label": "AI –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è"},
                {"id": "predict_performance", "label": "–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è"},
                {"id": "auto_scale", "label": "–ê–≤—Ç–æ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è"},
                {"id": "intelligent_sort", "label": "–†–æ–∑—É–º–Ω–µ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è"},
                {"id": "adaptive_learn", "label": "–ê–¥–∞–ø—Ç–∏–≤–Ω–µ –Ω–∞–≤—á–∞–Ω–Ω—è"},
                {"id": "cache_optimize", "label": "–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –∫–µ—à—É"},
            ],
        }

    def get_advanced_statistics(self) -> Dict[str, Any]:
        """–†–æ–∑—à–∏—Ä–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑ AI –º–µ—Ç—Ä–∏–∫–∞–º–∏"""
        base_stats = self.get_statistics()

        advanced_stats = {
            "ai_optimization_rate": getattr(self, "ai_optimization_rate", 0.0),
            "cache_hit_rate": self.cache_hit_rate,
            "cache_entries": self.cache_entries,
            "prediction_accuracy": getattr(self, "prediction_accuracy", 0.0),
            "resource_efficiency": getattr(self, "resource_efficiency", 0.0),
            "learning_progress": getattr(self, "learning_progress", 0.0),
            "system_load": self._get_system_metrics().__dict__,
        }

        return {**base_stats, **advanced_stats}

    # –ú–µ—Ç–æ–¥–∏ –¥–ª—è AI —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏

    def _optimize_task_priorities_simple(self, tasks: List[Dict]) -> List[Dict]:
        """–ü—Ä–æ—Å—Ç–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤ –∑–∞–≤–¥–∞–Ω—å"""
        return sorted(tasks, key=lambda t: t.get("priority", 0), reverse=True)

    async def _optimize_task_with_ai(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –∑–∞–≤–¥–∞–Ω–Ω—è"""
        # –°–∏–º—É–ª—è—Ü—ñ—è AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
        await asyncio.sleep(0.01)
        return {**task, "ai_optimized": True}

    async def _update_performance_metrics(
        self, task: Dict, execution_time: float, success: bool
    ):
        """–û–Ω–æ–≤–ª–µ–Ω–Ω—è –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        metrics = {
            "timestamp": datetime.now(),
            "task_type": task.get("type", "unknown"),
            "execution_time": execution_time,
            "success": success,
            "system_metrics": self._get_system_metrics().__dict__,
        }
        self.performance_history.append(metrics)

        # –û–±–º–µ–∂—É—î–º–æ —ñ—Å—Ç–æ—Ä—ñ—é
        if len(self.performance_history) > 1000:
            self.performance_history = self.performance_history[-500:]

    async def _context_aware_execution(
        self, task: Dict[str, Any], context: Optional[Dict]
    ) -> PluginResult:
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–ª–µ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è"""
        return PluginResult(
            success=True,
            message="–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–ª–µ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ",
            data={"context_used": context is not None},
        )

    async def _distributed_processing(self, task: Dict[str, Any]) -> PluginResult:
        """–†–æ–∑–ø–æ–¥—ñ–ª–µ–Ω–∞ –æ–±—Ä–æ–±–∫–∞"""
        return PluginResult(
            success=True,
            message="–†–æ–∑–ø–æ–¥—ñ–ª–µ–Ω–∞ –æ–±—Ä–æ–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
            data={"workers_used": 1},
        )

    async def _real_time_optimization(self, task: Dict[str, Any]) -> PluginResult:
        """–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ"""
        return PluginResult(
            success=True,
            message="–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
            data={"optimization_level": 0.85},
        )

    async def _predictive_maintenance(self, task: Dict[str, Any]) -> PluginResult:
        """–ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–µ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è"""
        return PluginResult(
            success=True,
            message="–ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–µ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ",
            data={"maintenance_score": 0.9},
        )

    def _analyze_workflow_efficiency(self, workflow_data: Dict) -> float:
        """–ê–Ω–∞–ª—ñ–∑ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ workflow"""
        return 0.75  # 75% –±–∞–∑–æ–≤–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å

    async def _apply_ai_optimization(self, workflow_data: Dict) -> Dict:
        """–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó"""
        # –°–∏–º—É–ª—è—Ü—ñ—è AI –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
        await asyncio.sleep(0.1)
        return {**workflow_data, "optimized": True, "efficiency_gain": 0.15}

    def _predict_improvement(self, current: float, optimized: Dict) -> float:
        """–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è"""
        return optimized.get("efficiency_gain", 0.1)

    def _get_historical_performance(self) -> List[Dict]:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ—Å—Ç–æ—Ä–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        return self.performance_history[-100:]  # –û—Å—Ç–∞–Ω–Ω—ñ 100 –∑–∞–ø–∏—Å—ñ–≤

    def _predict_future_performance(self, historical_data: List[Dict]) -> Dict:
        """–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –º–∞–π–±—É—Ç–Ω—å–æ—ó –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        if not historical_data:
            return {"predicted_tasks_per_second": 3.0, "confidence": 0.5}

        avg_performance = sum(
            h.get("tasks_per_second", 3.0) for h in historical_data
        ) / len(historical_data)
        return {"predicted_tasks_per_second": avg_performance * 1.1, "confidence": 0.8}

    def _identify_bottlenecks(self, historical_data: List[Dict]) -> List[str]:
        """–í–∏—è–≤–ª–µ–Ω–Ω—è –≤—É–∑—å–∫–∏—Ö –º—ñ—Å—Ü—å"""
        return ["cpu_usage", "memory_allocation"]

    def _generate_optimization_recommendations(
        self, bottlenecks: List[str]
    ) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π –ø–æ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó"""
        return [f"–û–ø—Ç–∏–º—ñ–∑—É–≤–∞—Ç–∏ {bottleneck}" for bottleneck in bottlenecks]

    def _predict_resource_needs(self, task: Dict[str, Any]) -> Dict[str, float]:
        """–ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –ø–æ—Ç—Ä–µ–± –≤ —Ä–µ—Å—É—Ä—Å–∞—Ö"""
        complexity = self._calculate_task_complexity(task)
        return {
            "cpu": min(complexity * 0.2, 1.0),
            "memory": min(complexity * 0.15, 1.0),
            "disk": min(complexity * 0.1, 1.0),
        }

    def _calculate_optimal_allocation(
        self, current_usage: AdvancedMetrics, resource_needs: Dict
    ) -> Dict:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–æ–∑–ø–æ–¥—ñ–ª—É —Ä–µ—Å—É—Ä—Å—ñ–≤"""
        return {
            "cpu": resource_needs.get("cpu", 0.5),
            "memory": resource_needs.get("memory", 0.5),
            "improvement": 0.15,
        }

    async def _apply_resource_allocation(self, allocation_plan: Dict) -> bool:
        """–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –ø–ª–∞–Ω—É —Ä–æ–∑–ø–æ–¥—ñ–ª—É —Ä–µ—Å—É—Ä—Å—ñ–≤"""
        # –°–∏–º—É–ª—è—Ü—ñ—è –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è
        await asyncio.sleep(0.05)
        return True

    def _analyze_current_load(self) -> Dict[str, float]:
        """–ê–Ω–∞–ª—ñ–∑ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è"""
        metrics = self._get_system_metrics()
        return {
            "cpu_load": metrics.cpu_usage / 100.0,
            "memory_load": metrics.memory_usage / 100.0,
            "task_queue": 0.5,
        }

    def _calculate_optimal_workers(self, current_load: Dict) -> int:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –≤–æ—Ä–∫–µ—Ä—ñ–≤"""
        base_workers = 2
        load_factor = current_load.get("cpu_load", 0.5)
        return max(1, min(base_workers + int(load_factor * 4), 8))

    async def _scale_workers(self, optimal_workers: int) -> Dict:
        """–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –≤–æ—Ä–∫–µ—Ä—ñ–≤"""
        # –°–∏–º—É–ª—è—Ü—ñ—è –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è
        await asyncio.sleep(0.1)
        return {"success": True, "workers": optimal_workers, "factor": 1.2}

    def _estimate_business_value(self, task: Dict[str, Any]) -> float:
        """–û—Ü—ñ–Ω–∫–∞ –±—ñ–∑–Ω–µ—Å-—Ü—ñ–Ω–Ω–æ—Å—Ç—ñ –∑–∞–≤–¥–∞–Ω–Ω—è"""
        priority = task.get("priority", 1)
        return min(priority / 10.0, 1.0)

    def _analyze_dependencies(self, task: Dict[str, Any]) -> List[str]:
        """–ê–Ω–∞–ª—ñ–∑ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç–µ–π –∑–∞–≤–¥–∞–Ω–Ω—è"""
        return task.get("dependencies", [])

    def _estimate_resource_needs(self, task: Dict[str, Any]) -> Dict[str, float]:
        """–û—Ü—ñ–Ω–∫–∞ –ø–æ—Ç—Ä–µ–± –≤ —Ä–µ—Å—É—Ä—Å–∞—Ö"""
        return self._predict_resource_needs(task)

    def _optimize_task_priorities(self, analyzed_tasks: List[Dict]) -> List[Dict]:
        """–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤ –∑–∞–≤–¥–∞–Ω—å"""
        # –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ composite score
        for task_data in analyzed_tasks:
            score = (
                task_data["complexity"] * self.priority_weights["complexity"]
                + len(task_data["dependencies"]) * self.priority_weights["dependencies"]
                + task_data["business_value"] * self.priority_weights["business_value"]
            )
            task_data["priority_score"] = score

        return sorted(analyzed_tasks, key=lambda t: t["priority_score"], reverse=True)

    def _calculate_priority_metrics(
        self, prioritized_tasks: List[Dict]
    ) -> Dict[str, Any]:
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–µ—Ç—Ä–∏–∫ –ø—Ä—ñ–æ—Ä–∏—Ç–∏–∑–∞—Ü—ñ—ó"""
        if not prioritized_tasks:
            return {"efficiency": 0.0, "balance": 0.0}

        avg_score = sum(t.get("priority_score", 0) for t in prioritized_tasks) / len(
            prioritized_tasks
        )
        return {
            "efficiency": min(avg_score, 1.0),
            "balance": 0.8,
            "total_tasks": len(prioritized_tasks),
        }

    def _collect_execution_data(self) -> List[Dict]:
        """–ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –¥–ª—è –Ω–∞–≤—á–∞–Ω–Ω—è"""
        return self.performance_history[-50:]  # –û—Å—Ç–∞–Ω–Ω—ñ 50 –∑–∞–ø–∏—Å—ñ–≤

    async def _train_adaptive_models(
        self, execution_data: List[Dict]
    ) -> Dict[str, Any]:
        """–ù–∞–≤—á–∞–Ω–Ω—è –∞–¥–∞–ø—Ç–∏–≤–Ω–∏—Ö –º–æ–¥–µ–ª–µ–π"""
        # –°–∏–º—É–ª—è—Ü—ñ—è –Ω–∞–≤—á–∞–Ω–Ω—è
        await asyncio.sleep(0.2)
        return {
            "improvement": 0.1,
            "accuracy": 0.85,
            "data_points": len(execution_data),
        }

    def _update_system_parameters(self, learning_results: Dict) -> Dict[str, Any]:
        """–û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤"""
        improvement = learning_results.get("improvement", 0)

        # –û–Ω–æ–≤–ª—é—î–º–æ –≤–∞–≥–∏ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤
        if improvement > 0.05:
            for key in self.priority_weights:
                self.priority_weights[key] *= 1 + improvement * 0.1

        return {
            "updated_weights": self.priority_weights,
            "improvement_applied": improvement,
        }
