DEV_PLAN.md: План Модернізації та Розробки NIMDA v3.2Версія: 2.0Дата: 11.07.2025Технологічний стек: Python 3.11+, PySide6 (Qt for Python), AsyncioГоловна мета: Створити інтелектуального, універсального та адаптивного помічника для управління ІТ-інфраструктурою з інтуїтивним голосовим та текстовим інтерфейсом, що імітує живе спілкування та забезпечує динамічне, кероване діалогом робоче середовище.1. Загальна Архітектура та Структура ПроєктуВ основі проєкту лежить асинхронна, модульна архітектура, що забезпечує гнучкість, масштабованість та легкість підтримки. Вибір PySide6 замість Tkinter є фундаментальним рішенням, що дозволяє реалізувати складний, динамічний та візуально насичений GUI, як того вимагає концепція.1.1. Візуальна Схема СтруктуриNIMDA/
│
├── run_nimda.py             # <- Єдина точка входу. Ініціалізує та запускає MainController.
│
├── Core/                    # <- Ядро системи, керуюча логіка та оркестрація.
│   ├── __init__.py
│   ├── main_controller.py     # Оркестратор: ініціалізує GUI, State, Агентів, Сервіси.
│   ├── agent_manager.py       # Керує життєвим циклом та взаємодією агентів.
│   └── command_engine.py      # Виконує CLI-команди, динамічно обираючи плагін.
│
├── State/                   # <- Централізоване управління станом (Redux-like).
│   ├── __init__.py
│   ├── store.py               # Сховище стану (Single Source of Truth).
│   ├── actions.py             # Визначення всіх можливих дій у системі.
│   └── reducers.py            # Чисті функції для зміни стану.
│
├── Agents/                  # <- Модуль інтелектуальних агентів.
│   ├── __init__.py
│   ├── chat_agent.py          # Агент-Співрозмовник (AI №1): веде діалог, інтерпретує наміри.
│   └── worker_agent.py        # Агент-Технік (AI №2): виконує завдання, керує GUI.
│
├── Intelligence/            # <- Модулі, що реалізують інтелектуальні можливості.
│   ├── __init__.py
│   ├── adaptive_thinker.py    # Система різінгового послідовного мислення (Chain of Thought).
│   └── learning_module.py     # Система навчання на основі успішних кейсів.
│
├── GUI/                     # <- Все, що стосується графічного інтерфейсу на PySide6.
│   ├── __init__.py
│   ├── main_window.py         # Головне вікно, що містить панелі.
│   ├── chat_panel.py          # Ліва панель: історія чату, поле вводу, кнопки.
│   ├── display_canvas.py      # Права панель: QGraphicsView для динамічних вікон.
│   ├── output_widgets/        # Колекція кастомних віджетів для виводу (логи, таблиці).
│   │   ├── log_widget.py
│   │   └── table_widget.py
│   ├── gui_controller.py      # API для агентів для маніпуляції GUI.
│   └── theme.py               # Конфігурація "хакер-мотиву" через QSS.
│
├── Plugins/                 # <- Модульна система для взаємодії з різними CLI.
│   ├── __init__.py
│   ├── base_provider.py       # Абстрактний клас, що визначає інтерфейс провайдера.
│   ├── providers/             # Директорія з готовими плагінами (MikroTik, Linux, Cisco).
│   └── universal_adapter.py   # Адаптер для автоматичного створення CLI-драйверів.
│
├── Services/                # <- Зовнішні та внутрішні допоміжні сервіси.
│   ├── __init__.py
│   ├── voice_service.py       # Абстракція для TTS/STT (Google, macOS).
│   ├── translator_service.py  # Сервіс реверсивного перекладу RU <-> EN.
│   ├── doc_parser_service.py  # Парсинг та індексація технічної документації.
│   └── vectorizer_service.py  # Створення векторних представлень тексту.
│
├── Configs/                 # <- Файли конфігурації та налаштувань.
│   ├── providers.json         # Налаштування ЛЛМ-провайдерів (API ключі, моделі).
│   └── app_settings.json      # Загальні налаштування (тема, мова, поріг якості).
│
└── Data/                    # <- Дані, що генеруються та використовуються системою.
    ├── knowledge_base/        # База знань (векторна база даних).
    ├── cli_docs_cache/        # Кеш проіндексованої документації для плагінів.
    └── logs/                  # Папка для логів роботи системи.
        └── nimda.log

---

## 2. Модель Взаємодії та Ролі Агентів

Це ключова концепція проєкту. NIMDA не є пасивним виконавцем, а проактивним асистентом з чітким розподілом обов'язків між двома агентами.

### 2.1. Агент №1: `chat_agent.py` (Співрозмовник та Інтерпретатор)
**Опис:** Це "обличчя" та "соціальний інтелект" NIMDA. Його головне завдання — створити для користувача комфортну атмосферу живого спілкування.
**Функціонал:**
1.  **Ведення вільного діалогу:** Підтримує розмову, використовуючи природну мову. Приймає ввід через голос (`voice_service`) та текстове поле.
2.  **Прозора трансляція:** Використовує `translator_service` для перекладу запитів користувача (RU -> EN) перед відправкою до ЛЛМ та відповідей (EN -> RU) перед відображенням/озвученням.
3.  **Розпізнавання намірів (Intent Recognition):** Аналізує кожну фразу користувача для виявлення прихованих завдань, включаючи команди керування GUI ("зроби вікно логів більшим").
4.  **Декомпозиція та Формалізація:** Перетворює нечіткі запити ("щось все гальмує, подивись там на мікротіку") у чіткі, атомарні, структуровані завдання у форматі JSON для другого агента.
5.  **Диспетчеризація:** Відправляє дії (`Actions`) до центрального сховища (`Store`), ініціюючи роботу `worker_agent`.
6.  **Контроль якості:** Отримує звіт від Агента №2, порівнює його з рівнем вимог з `app_settings.json` і приймає рішення: або показати результат користувачеві, або відправити завдання на доопрацювання.

### 2.2. Агент №2: `worker_agent.py` (Технічний Виконавець та UI-Оркестратор)
**Опис:** Це "руки" та "технічний мозок" NIMDA. Він ніколи не спілкується з користувачем напряму. Його світ — це структуровані JSON-завдання, CLI та маніпуляції з GUI.
**Функціонал:**
1.  **Обробка черги завдань:** Підписується на дії `NEW_TASK` у `Store` та приймає JSON-об'єкти від Агента №1.
2.  **Планування робочого простору:** **Критична функція.** Перед виконанням технічного завдання він вирішує, як оптимально представити майбутні результати. Він надсилає команди в `gui_controller` для створення, розміщення та налаштування необхідних адаптивних вікон на `display_canvas`.
3.  **Використання інтелектуальних модулів:** Для вирішення завдань активує `learning_module` для пошуку готових рішень. Якщо їх немає, активує `adaptive_thinker` для побудови нового ланцюжка команд.
4.  **Взаємодія з `command_engine`:** Надсилає згенеровані команди на виконання через відповідний CLI-плагін.
5.  **Формування звіту:** Збирає всі технічні дані (вивід команд, логи), структурує їх і надсилає фінальний звіт Агенту №1 через дію `TASK_COMPLETED`.

---

## 3. Деталізація Інтелектуальних Систем

### 3.1. Різінгова Послідовна Система Мислення (`Intelligence/adaptive_thinker.py`)
**Мета:** Вирішувати складні, нетривіальні задачі шляхом ітеративного побудови логічного ланцюжка кроків (Chain of Thought).
**Алгоритм роботи:**
1.  **Вхід:** Отримує мету від `worker_agent`, наприклад: `user_goal: "diagnose_network_latency_on_mikrotik"`.
2.  **Гіпотеза №1:** ЛЛМ генерує першу гіпотезу: `"Проблема може бути в завантаженні CPU роутера"`.
3.  **Запит до адаптера:** `adaptive_thinker` формує семантичний запит до `universal_adapter`: `get_command_for_intent("check_cpu_load")`.
4.  **Виконання:** Адаптер повертає команду (`/system resource print`), `command_engine` її виконує.
5.  **Аналіз:** Модуль аналізує вивід за допомогою ЛЛМ.
    *   **Якщо `cpu-load > 90%`:** Гіпотеза вірна. Наступна гіпотеза №1.1: `"Знайти процес, що навантажує CPU"`. Новий запит: `get_command_for_intent("list_processes_by_cpu")`.
    *   **Якщо `cpu-load < 10%`:** Гіпотеза хибна. Альтернативна гіпотеза №2: `"Проблема може бути в завантаженні каналу"`. Новий запит: `get_command_for_intent("check_interface_traffic")`.
6.  **Вихід:** Процес триває до знаходження причини або вичерпання гіпотез. На виході формується повний звіт з усіма кроками, командами та знайденими даними.

### 3.2. Система Навчання (`Intelligence/learning_module.py` та `Data/knowledge_base/`)
**Мета:** Акумулювати досвід для миттєвого вирішення раніше бачених задач, використовуючи векторну базу даних.
**Технологія:** Легка вбудована векторна база даних (напр., **FAISS**, **Chroma**).
**Процес запису:**
1.  Коли Агент №1 підтверджує успішне виконання завдання, `learning_module` зберігає весь кейс у векторну БД.
2.  **Структура запису:**
    *   `intent_vector`: Векторне представлення запиту користувача.
    *   `user_intent_text`: Оригінальний текст запиту.
    *   `successful_reasoning_chain`: Послідовність команд, що призвела до успіху.
    *   `required_gui_layout`: JSON-опис вікон, які потрібні для відображення результату.
    *   `success_rating`: Рейтинг успішності.

**Процес використання:**
1.  При новому запиті `vectorizer_service` перетворює його на вектор.
2.  `learning_module` шукає найбільш схожий `intent_vector` в базі знань.
3.  Якщо знайдено запис з високим рейтингом, `worker_agent` пропускає етап "мислення" і одразу виконує готову послідовність команд, попередньо налаштувавши GUI згідно з `required_gui_layout`.

---

## 4. Деталізація Модулів

### 4.1. GUI (PySide6)
**Ключова ідея:** Інтерфейс складається з двох частин: статичної лівої панелі для діалогу та динамічної правої панелі-полотна (`QGraphicsView`), де `worker_agent` створює та керує вікнами виводу.

*   **`theme.py`:** Використовує **QSS (Qt Style Sheets)**, аналог CSS, для глибокої кастомізації.
    ```python
    HACKER_THEME = """
    QMainWindow, QWidget {
        background-color: #0A0A0A;
        color: #00FF41;
        border: 1px solid #00FF41;
    }
    /*... інші стилі для кнопок, полів вводу і т.д. */
    """
    ```
*   **`gui_controller.py`:** Надає API для агентів.
    ```python
    class GuiController:
        def create_widget(self, widget_type: str, name: str, position: tuple, size: tuple):...
        def update_widget_content(self, name: str, content: str, streaming: bool):...
        def remove_widget(self, name: str):...
        def move_widget(self, name: str, x: int, y: int):...
    ```
*   **`display_canvas.py`:** Реалізує `QGraphicsView` та `QGraphicsScene`. `GuiController` буде додавати на сцену віджети, обгорнуті в `QGraphicsProxyWidget`, що робить їх рухомими та масштабованими. [1, 2]
*   **`main_window.py`:** Реалізація анімації "Матриці" на фоні `display_canvas` за допомогою `QPainter` в методі `drawBackground` сцени, з низьким пріоритетом оновлення, щоб не навантажувати CPU. [3]

### 4.2. Plugins та Universal Adapter
**Мета:** Повна незалежність від конкретного CLI.

*   **`base_provider.py`:** Абстрактний клас з методами `connect`, `disconnect`, `execute_command`, та найважливішим:
    ```python
    from abc import ABC, abstractmethod

    class BaseProvider(ABC):
        @abstractmethod
        async def get_command_for_intent(self, intent_description: str) -> str:
            pass
        #... інші методи...
    ```
*   **`universal_adapter.py`:**
    *   **Фаза ініціалізації:** Користувач вказує шлях до PDF/TXT документації. `doc_parser_service` та `vectorizer_service` парсять її, створюють вектори "опис функціоналу -> команда" та зберігають їх у локальний кеш (напр., FAISS файл у `Data/cli_docs_cache/`). [4, 5, 6]
    *   **Фаза виконання:** Метод `get_command_for_intent("переглянути таблицю ARP")` перетворює текстовий намір на вектор і здійснює семантичний пошук по базі векторів документації, знаходячи найбільш релевантну команду (напр., `show arp` або `/ip arp print`).

### 4.3. Services
*   **`voice_service.py`:** Реалізує STT/TTS. Включає **VAD (Voice Activity Detection)** за допомогою `webrtcvad` для оптимізації, щоб надсилати на розпізнавання лише голосові дані, а не тишу, що зменшує трафік та вартість. [7, 8]
*   **`translator_service.py`:** Простий асинхронний клас, що використовує обрану в налаштуваннях ЛЛМ для перекладу з коротким системним промптом.

### 4.4. Configs
*   **`app_settings.json`:**
    ```json
    {
      "user_name": "Admin",
      "default_theme": "hacker_green",
      "quality_threshold": "high",
      "language": "ru",
      "voice_activation_phrase": "NIMDA",
      "active_llm_provider": "gemini"
    }
    ```
*   **`providers.json`:**
    ```json
    {
      "gemini": { "api_key": "YOUR_API_KEY", "model": "gemini-1.5-pro" },
      "ollama": { "host": "http://localhost:11434", "model": "llama3" },
      "mistral": { "api_key": "YOUR_API_KEY", "model": "mistral-large-latest" }
    }
    ```

---

## 5. Дорожня Карта Розробки

*   **Фаза 1: Ядро та Каркас GUI.**
    *   Налаштування структури проєкту, `asyncio`, `PySide6`.
    *   Реалізація базового `Store` (Redux).
    *   Створення статичного GUI: `main_window` з `chat_panel` та порожнім `display_canvas`.

*   **Фаза 2: Базовий Потік "Запит-Відповідь".**
    *   Реалізація `chat_agent` та `worker_agent` з простою комунікацією через `Store`.
    *   Створення `command_engine` та першого простого плагіна (напр., для локального `Linux`).
    *   Інтеграція `translator_service`.

*   **Фаза 3: Інтелектуальний Шар.**
    *   Реалізація `adaptive_thinker` для побудови ланцюжків команд.
    *   Реалізація `learning_module` з векторною базою даних FAISS.

*   **Фаза 4: Універсалізація та Динамічний GUI.**
    *   Розробка `universal_adapter` з парсингом документації.
    *   Реалізація `gui_controller` та динамічного створення/управління віджетами на `display_canvas`.

*   **Фаза 5: Сервіси та Фіналізація.**
    *   Інтеграція `voice_service` з VAD.
    *   Додавання глобальних гарячих клавіш.
    *   Ретельне тестування, оптимізація та пакування.
